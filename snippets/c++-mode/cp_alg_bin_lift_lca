#key: binlift
#name: build binary lifting and LCA
# --
// for LCA, node.parent points back
void build_binary_lift(graph& g, pnode root) {
  queue<pnode> q;
  root->level = 0;
  q.emplace(root);
  while (not q.empty()) {
    auto u = q.front(); q.pop();
    for (auto v : u->adjusted) {
      if (v->parent != u) continue;
      v->level = u->level + 1;
      auto t = u;
      v->up.emplace_back(t);
      l k = 0;
      while (t->up.size() > k) {
        t = t->up[k];
        v->up.emplace_back(t);
        k++;
      }
      q.emplace(v);
    }
  }
}

pnode lift(pnode a, l n) {
  l k = 0;
  while (n) {
    if (n % 2) a = a->up[k];
    k++;
    n /= 2;
  }
  return a;
}

pnode lca(pnode a, pnode b) {
  if (a->level < b->level) swap(a, b);
  a = lift(a, a->level - b->level);
  if (a == b) return a;
  for (l k = a->up.size() - 1; k >= 0; k--) {
    if (a->up.size() > k and a->up[k] != b->up[k]) {
      a = a->up[k];
      b = b->up[k];
    }
  }
  return a->up[0];
}